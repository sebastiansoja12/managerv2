package com.warehouse.supplier;

import com.warehouse.commonassets.enumeration.PackageType;
import com.warehouse.commonassets.helper.Result;
import com.warehouse.commonassets.identificator.DeviceId;
import com.warehouse.commonassets.identificator.SupplierCode;
import com.warehouse.commonassets.identificator.SupplierId;
import com.warehouse.supplier.domain.exception.SupplierAlreadyExistsException;
import com.warehouse.supplier.domain.model.Supplier;
import com.warehouse.supplier.domain.port.primary.SupplyPortImpl;
import com.warehouse.supplier.domain.port.secondary.DeviceServicePort;
import com.warehouse.supplier.domain.port.secondary.SupplierRepository;
import com.warehouse.supplier.domain.registry.DomainContext;
import com.warehouse.supplier.domain.service.*;
import com.warehouse.supplier.domain.vo.*;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.jupiter.api.function.Executable;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationEventPublisher;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;


@ExtendWith(MockitoExtension.class)
public class SupplyPortImplTest {

    @Mock
    private SupplierRepository supplierRepository;

    @Mock
    private DeviceServicePort deviceServicePort;

    private SupplyPortImpl supplyPort;

    @BeforeEach
    void setup() {
        final SupplierService service = new SupplierServiceImpl(supplierRepository);
        final SupplierValidatorService validatorService = new SupplierValidatorServiceImpl(supplierRepository, deviceServicePort);
        final SupplierCodeGeneratorService generatorService = new SupplierCodeGeneratorServiceImpl();
        final DriverLicenseService driverLicenseService = new DriverLicenseServiceImpl();
        final ApplicationContext applicationContext = mock(ApplicationContext.class);
        final ApplicationEventPublisher eventPublisher = mock(ApplicationEventPublisher.class);
        final DomainContext domainContext = new DomainContext();
        domainContext.setApplicationEventPublisher(eventPublisher);
        domainContext.setApplicationContext(applicationContext);
        supplyPort = new SupplyPortImpl(service, generatorService, validatorService, driverLicenseService, deviceServicePort);
    }

    @Test
    @DisplayName("Create supplier when supplier code is correct")
    void shouldCreateSupplier() {
        final SupplierCode supplierCode = new SupplierCode("123456");
        final SupplierCreateRequest request = new SupplierCreateRequest(supplierCode, "test", "test", "test");
        final SupplierCreateResponse response = supplyPort.create(request);
        assertEquals(supplierCode, response.supplierCode());
    }

    @Test
    @DisplayName("Create supplier when supplier code is shorter than six characters")
    void shouldCreateSupplierWithNewCode() {
        final SupplierCode supplierCode = new SupplierCode("13");
        final SupplierCreateRequest request = new SupplierCreateRequest(supplierCode, "test", "test", "test");
        final SupplierCreateResponse response = supplyPort.create(request);
        assertNotEquals(supplierCode, response.supplierCode());
    }

    @Test
    @DisplayName("Create supplier when supplier code is empty")
    void shouldCreateSupplierAutogeneratedCode() {
        final SupplierCreateRequest request = new SupplierCreateRequest(null, "test", "test", "test");
        final SupplierCreateResponse response = supplyPort.create(request);
        assertNotNull(response.supplierCode());
    }

    @Test
    void shouldNotGenerateSupplierCodeWhenAlreadyOneExists() {
        final SupplierCode supplierCode = new SupplierCode("123456");
        final SupplierCreateRequest request = new SupplierCreateRequest(supplierCode, "test", "test", "test");
        when(supplierRepository.findByCode(supplierCode)).thenReturn(mock(Supplier.class));
        final Executable executable = () -> supplyPort.create(request);
        final SupplierAlreadyExistsException exception = assertThrows(SupplierAlreadyExistsException.class, executable);
        assertEquals(String.format("Supplier with code %s already exists", supplierCode), exception.getMessage());
    }

    @Test
    void shouldGetOneById() {
        final Supplier supplier = mock(Supplier.class);
        final SupplierId supplierId = new SupplierId(1L);
        when(supplierRepository.findById(supplierId)).thenReturn(supplier);
        final Supplier supplierDb = this.supplyPort.getOneById(supplierId);
        assertEquals(supplier, supplierDb);
    }

    @Test
    void shouldGetOneByCode() {
        final Supplier supplier = mock(Supplier.class);
        final SupplierCode supplierCode = new SupplierCode("123");
        when(supplierRepository.findByCode(supplierCode)).thenReturn(supplier);
        final Supplier supplierDb = this.supplyPort.getOneByCode(supplierCode);
        assertEquals(supplier, supplierDb);
    }

    @Test
    void shouldAddPackageType() {
        final ChangeSupportedPackageTypeRequest request = new ChangeSupportedPackageTypeRequest(new SupplierCode("123"), PackageType.LARGE);
        when(supplierRepository.findByCode(new SupplierCode("123"))).thenReturn(mock(Supplier.class));
        this.supplyPort.addPackageType(request);
        verify(supplierRepository).update(any());
    }

    @Test
    void shouldAddDevice() {
        final DeviceId deviceId = new DeviceId(1L);
        final ChangeSupplierDeviceRequest request = new ChangeSupplierDeviceRequest(new SupplierCode("123"), deviceId);
        when(deviceServicePort.validateDevice(deviceId)).thenReturn(Result.success(null));
        when(supplierRepository.findByCode(new SupplierCode("123"))).thenReturn(mock(Supplier.class));
        this.supplyPort.addDevice(request);
        verify(supplierRepository).update(any());
    }
}
